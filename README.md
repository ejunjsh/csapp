# csapp(e3)
my csapp(e3) homework

ref https://github.com/DreamAndDead/CSAPP-3e-Solutions

# summary

## 计算机系统漫游

> 这一章里面基本是对整本书的一个概括吧。

* gcc 翻译源码的的四个阶段：预处理，编译，汇编，链接
* 系统硬件组成：总线，I/O设备，主存，处理器
* 存储设备的层次结构：L0(寄存器)，L1,L2,L3(SRAM),L4(主存DRAM),L5(磁盘),L6(...)
* 并发运行则是说一个进程的指令和另一个进程的指令交错执行的
* 无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。
* 操作系统实现这种交错执行的机制称为上下文切换
* 虚拟内存是一个抽象概念，它为每个进程提供一个假象，即每个进程都是独占地使用主存。每个进程看到的内存都是一致的，称为虚拟内存空间
* 每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩
* 一个进程实际上可以由多个称为线程的执行单位组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。
* 超线程是一项允许一个cpu执行多个控制流的技术
* 利用直接存储器存取（DMA）技术，数据可以不通过处理器而直接从磁盘到达主存。


## 信息的表示和处理

* 大多数计算机使用8位的块，或者字节（byte）,作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，成为虚拟内存。内存的每个字节都由一个唯一的数字来表识，称为它的地址，所有可能的地址的集合就称为虚拟内存空间
* c的指针包含值和类型，它的值表示某个对象的位置，它的类型表示那个位置上所存储对象的类型
* 对于一个字长为w位的机器，虚拟地址范围为0～2^w-1,程序最多访问2^w个字节
* 最低有效字节在最前面的方式，称为小端法，最高有效字节在最前面的方式，称为大端法。
* 最常见的有符号数的计算机表示方式就是补码
* 几乎所有的编译器/机器组合都对有符号数使用算数右移
* 对于大多数c语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会改变，但是位模式不变
* 两个数的w位补码之和与无符号之和有完全相同的位级表示，乘法也一样

## 程序的机器级表示

> 这篇是汇编相关，精华👿

* 汇编代码是机器代码的文本表示
* 目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。
* x86-64的虚拟地址是由64位的字来表示的，目前的实现中，高16位都必须设置为0，所以一个地址实际上能够指定的是2^48或者64TB范围内的一个字节。
* 传送指令的两个操作数不能都指向内存位置
* 由于是从16位体系结构扩展成32位的，Intel用术语“字(word)”表示16位数据类型。因此，32位数为“双字(double words)”，64位数为“四字(quad words)”
* 函数通过把值存储在寄存器%rax或寄存器的某个低位部分中返回
* 栈向下增长，栈顶元素的地址是所有栈中元素地址中最低的，栈指针%rsp保存着栈顶元素的地址。
* 跳转指令有几种不同的编码，但是最常用都是PC相对的(PC-relative)
* 将栈指针减少一个适当的量可以为没有指定初始值的数据在栈上分配空间。类似的，可以通过增加栈指针来释放空间
* 当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分成为过程的栈帧(stack frame)
* 可以通过寄存器最多传递6个整型（例如整数和指针）的参数，超出6个的部分就要通过栈来传递
* 根据惯例，寄存器%rbx,%rbp和%r12～%r15被划分为被调用者保存寄存器
* 所有其他的寄存器，除了栈指针%rsp,都分类为调用者保存寄存器
* 数组元素在内存中按照“行优先”的顺序排列
* 一个联合的总大小等于它最大字段的大小
* 对齐原则是任何k字节的基本对象的地址必须是k的倍数
* 将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值，指针也可以指向函数
* 为了管理变长栈帧，x86-64代码使用寄存器%rbp作为帧指针（有时候称为基指针）

## 

> to be continue....